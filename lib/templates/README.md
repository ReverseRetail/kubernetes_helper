# Kubernetes app configuration

## Cluster connection
- Create the project on Gcloud
- Set the project where to work on     
    `gcloud config set project my-project`
    
- Create the cluster (Only if not exist)    
    `gcloud container clusters create my-cluster`
    `# gcloud container clusters list --region europe-west4-a # to list clusters`
    Note: `--preemptible` recommended for non production environments   
  
- Use the cluster/project as default    
    `gcloud container clusters get-credentials my-cluster --zone europe-west4-a`
  
## App setup
- Install kubernetes-helper (if not installed yet)    
  `gem install kubernetes_helper`  
  
- Verify or update k8s settings in `.kubernetes/settings.rb`        
  Note: Please do not include sensitive values in this file, secrets are recommended instead.

- Register shared cloudsql proxy configuration to connect application to the Database/Pubsub (only if it does not exist yet)    
    ```bash
    DEPLOY_ENV=beta kubernetes_helper run_command "kubectl create secret generic <%=deployment.cloud_secret_name%> --from-file=credentials.json=<path-to-downloaded/credentials.json>"
    ```
    
- Register manually env vars     
    Open and register secret values in `.kubernetes/secrets.yml`     
    ```bash
    DEPLOY_ENV=beta kubernetes_helper run_yml 'secrets.yml' 'kubectl create'
    # kubectl get secrets # to list all secrets registered
    ```

- Create deployment to run application    
    ```bash
    DEPLOY_ENV=beta kubernetes_helper run_yml 'deployment.yml' 'kubectl create'
    # kubectl get deployment # to list deployments
    ```

- Create service to connect pods and ingress    
    ```bash
    DEPLOY_ENV=beta kubernetes_helper run_yml 'service.yml' 'kubectl create'
    # kubectl get services # to list all registered services
    ```

- Create the public ip address (only if static ip is required)    
    ```bash
    DEPLOY_ENV=beta kubernetes_helper run_command "gcloud compute addresses create <%=ingress.ip_name%> --global"
    # gcloud compute addresses list # to list static ips generated
    # Copy new external ip generated by the previous command and point your domain to it
    ```
  
- Register ingress to receive external http calls (includes ssl certificates if defined)    
    ```bash
    DEPLOY_ENV=beta kubernetes_helper run_yml 'ingress.yml' 'kubectl create'
    # kubectl get ingress # to list all registered ingresses
    # kubectl get ManagedCertificate # to list all certificates
    # Domain and ssl propagation can take more than 10 minutes
    # You can start accessing to the app using the generated ip address
    # `kubectl get ManagedCertificate` # to see the status of ssl provisionning
    ```
- Update your domain to point to the new generated ip address (if required) and visit the domain or the ip address to see your application.     
  Note: The domain name propagation can take some time before pointing to the new ip address.     
  Note2: If the application shows "404 not found", check the deployment/pods status by: `kubectl get pods`    
  Note3: If the pod error is `ImagePullBackOff`, it is because the application docker image is missing. 
  You can deploy your application via github actions or similar (see #Configure-continuous-deployment-for-github-actions) or do it manually (see #Deploy-application-manually)

## Deploy application manually
Run the deployment manually with:     
```bash
  DEPLOY_ENV=beta kubernetes_helper run_deployment 'cd.sh'
```     
The application image will be create and uploaded to the configured container registry (application pods should be restarted with the new docker image).      
Visit the application url to see changes.

## Configure continuous deployment for github actions
This gem comes with continuous deployment script out of the box which can be executed with a single line of code.
* Go to github repository settings    
* Register a new secret variable with content downloaded from (for google cloud) https://console.cloud.google.com/iam-admin/serviceaccounts 
    (Make sure to attach a "Editor", "Storage Admin" and "Kubernetes engine cluster admin" role to the service account)
  ```bash
    BETA_CLOUD_TOKEN=<secret content here>
    PROD_CLOUD_TOKEN=<secret content here>
  ```
  
* Add github workflow to automatically run deployment when merged into master or staging, something like:    
```yml
name: "Continuous Deployment"
on:
  push:
    branches: 
      - master
      - staging

deployment:
  runs-on: ubuntu-latest
  jobs:
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ env.DEPLOY_BRANCH }}
      - name: Cancel previous Workflow Actions
        uses: styfle/cancel-workflow-action@0.6.0
        with:
          access_token: ${{ github.token }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@master
      - uses: satackey/action-docker-layer-caching@v0.0.11
        continue-on-error: true
        with:
          key: CD-docker-cache-${{ hashFiles('Dockerfile', 'Gemfile.lock') }}

      #### App deployment          
      - run: sudo gem install kubernetes_helper
      - name: App deployment
        env:
          KB_AUTH_TOKEN: ${{ github.ref_name == 'master' && secrets.PROD_CLOUD_TOKEN || secrets.BETA_CLOUD_TOKEN }}
          DEPLOY_ENV: ${{ github.ref_name == 'master' && 'production' || 'beta' }}
        run: kubernetes_helper run_deployment 'cd.sh'
```   
  
## Apply any k8s setting changes
- Secrets    
  Open kubernetes secrets and add/edit/remove values and then save it    
  `kubectl edit secret ...`
  Once secrets were updated, then restart all related pods, see: https://medium.com/devops-dudes/how-to-propagate-a-change-in-kubernetes-secrets-by-restarting-dependent-pods-b71231827656
  
- Other settings    
  ```bash
    DEPLOY_ENV=beta kubernetes_helper run_yml 'deployment.yml' 'kubectl apply'
  ```  